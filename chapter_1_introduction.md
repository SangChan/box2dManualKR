# Chapter 1 introduction

# 1.1 About

Box2D는 게임용 2차원 강체 시뮬레이션 라이브러리입니다. 프로그래머는 게임내 오브젝트가 리얼하게 움직일 수 있도록 하고, 게임을 좀더 인터랙티브 하게 만들 수 있습니다. 게임엔진 입장에서 보자면, 물리엔진은 애니메이션이 물흐르듯이 보일 수 있도록 돕는 역할일 뿐입니다.
Box2D 는 Portable C++ 로 쓰여졌습니다. 이 엔진에 의해 정의된 변수명에서는 b2 가 앞에 붙습니다. 이 법칙이 당신의 게임 엔진과 충돌이 나지 않기를 바랍니다.

# 1.2 Prerequisites

본 매뉴얼은 독자가 물리의 기본적 개념인 질량, 힘, 회전력, 충돌를 생소하지 않게 느낄 것이라고 가정합니다. 아니라면 위키피디아나 구글 검색을 해보세요.
Box2D는 GDC(게임 개발자 컨퍼런스) 에서 물리 분야 튜토리얼을 진행하기 위해 만들어졌습니다. box2d.org 에 다운로드 섹션에서 이 튜토리얼을 다운 받을 수 있습니다.
Box2D가 c++ 로 쓰여졌으므로, c++에 어느정도 경험이 있길 바랍니다. Box2D가 당신의 첫 c++ 프로젝트가 아니길 바랍니다. 당산은 디버그, 링크, 컴파일 정도는 수월하게 할 수 있어야 합니다.

	(주의) 
	Box2D 는 당신의 첫 c++ 프로젝트 여서는 안됩니다. 
	반드시 c++ 에 대해 배우세요. 컴파일, 링크, 디버그 관련 소스는 인터넷에 많습니다.



# 1.3 About this Manual

본 매뉴얼은 Box2D API 를 주로 다루고 있으나 모든 측면을 충족시키지는 못합니다. Box2D 에 대해 더 알고싶은게 있다면 소스에 포함된 testbed 를 참조하시길 권합니다. 또한, Doxygen에 대응하도록 Box2D 주석을 달았으니 API 문서를 생성하는 것은 쉬울 것입니다.
새버전이 나오면 본 문서도 업데이트 됩니다. 소스 콘트롤에 포함되어 있는 버전은 오래된 것일 수 있습니다.

# 1.4 Feedback and Reporting Bugs

질문이 있거나, 피드백이 필요하다면 포럼에 글을 남기세요. 토론에 특화된 곳입니다.
구글 코드 프로젝트를 통해 이슈를 발행하고 있으며, 이를 통해 당신에 제시한 이슈도 잊혀지질 않습니다.
http://code.google.com/p/box2d/ 을 통해 버그 신고나 기능 요청을 해주세요.
자세한 정보를 함께 제공해 주시기 바랍니다. testbed 예제 프로젝트는 여러 문제를 보완해 줄 것입니다. 뒤쪽에서 자세히 설명하겠습니다.

# 1.5 Core Concepts

Box2D 는 몇가지 개념과 물체를 통해 작동합니다. 몇 가지 물체의 정의에 대해 설명하고 뒤에서 더 자세히 설명하도록 하겠습니다.

## shape
원이나 다각형 같은 2차원 기하학적 물체입니다.

## rigid body 
 강체. 딱딱한 덩어리형태의 물질. 물체를 구성하는 임의의 두 입자 사이의 거리가 항상 변하지 않습니다. 다이아몬드 정도의 경도를 가지고 있습니다. 임의의 물체를 나타낼때는 항상 강체를 의미합니다.

## fixture 
물체에 형태를 붙이고, 밀도, 마찰, 탄력 같은 속성을 추가합니다.

## constraint 
제약이란 물체의 자유도를 제거하는 물리적인 연결을 뜻합니다. 2차원 물체는 2개의 이동 좌표와 1개의 회전 좌표와 같은 3가지 자유도를 가지고 있습니다. 펜듈럼 처럼 벽에 물체를 핀으로 고정하여 속박할 수 있습니다. 이를 통해 물체는 핀을 통해서만 회전 할 수 있으며, 이로인해 2개의 자유도는 빼앗깁니다.

## contact constraint 
강체의 관통을 방지하며, 마찰과 탄력을 시뮬레이트 합니다. 특별히 만들지 않아도 Box2D 에서 자동으로 생성해 줍니다.

## joint 
2개 이상의 물체에 함께 제약을 가하기 위해 사용됩니다. Box2D 는 외접, 원거리, 각기둥 형 등의 joint 를 지원하며, 몇몇 형태는 제약 및 원동기를 가지고 있습니다.

## joint limit 
 관절 움직임의 반경에 제약을 겁니다. 사람 팔꿈치를 생각하시면 되겠습니다.

## joint motor 
관절의 자유도에 입각해 연결된 물체의 움직임을 일으키는 것입니다. 예를 들자면, 팔꿈치 회전을 일으키는 것 같은 겁니다. (역주: 팔꿈치 관절이 톱니가 두개 물려있는 형태라고 할때 한쪽 톱니에 모터를 연결해 돌리면 팔꿈치가 돌아가는 것 이라고 생각하시면 됩니다)

## world
 물리적인 세계는 물체, 제약, 고정값이 모여 상호작용하는 것입니다. Box2D 는 여러 개의 world 를 생성하도록 도울 수 있지만, 보통 반드시 필요한 것은 아닙니다.

## solver 
 시간, 충돌, 관절 등의 제어에 사용됩니다.  Box2D solver 는 성능 좋은 반복자로 제약이 필요할 때마다 몇번이고 사용이 가능합니다.

## continuos collision 
solver 는 물체의 진행을 제시간에 나타내기 위해 이산 시간 단계를 사용합니다. 때문에 충돌등의 문제 없이 터널링(장벽투과)으로 이어질 수 있습니다. 

Box2D는 이 터널링을 처리하기 위한 특수한 알고리즘을 가지고 있습니다. 첫째, 충돌 알고리즘은 두 개의 물체 첫 충돌 시의 시간 (TOI) 를 보간작업을 통해 찾아낼 수 있습니다. 둘째, sub-stepping solver 가 첫 충돌시로 물체를 옮겨 충돌을 처리할 수 있습니다.

# 1.6 Modules

Box2D 는 Common, Collision, Dynamic 3개의 모듈로 이루어져 있습니다. Common 모듈은 위치, 수학, 설정 관련 코드를 가지고 있습니다. Collision 모듈은 도형 정의, 충돌 함수 및 관리, broad-phase(빠르게 충돌 가능성있는 물체를 도출해내는 알고리즘) 를 가지고 있습니다. Dynamic 모듈에는 world, 물체, fixture, joint 를 포함하고 있습니다.
 

# 1.7 Units

Box2D는 부동소수점 숫자를 사용하며, 허용오차를 사용해 Box2D 의 성능을 끌어올리고 있습니다. 허용오차는 MKS(meters-kilomgram-second) 유닛에서 값 조정에 사용되고 있습니다. 사실, Box2D는 0.1 ~ 10 미터 정도의 운동 물체에 대해 제대로 작동하도록 조정되어 있습니다. 따라서 수프 캔 ~ 버스 정도의 사이즈에서만 제대로 작동한다는 의미입니다. 고정된 물체는 50미터가 넘어도 별 문제는 없습니다.
보통 2차원 물리 엔진에서는 당신의 캐릭터 유닛을 픽셀단위로 취급하는데 불행히도 이것은 매우 안좋은 시뮬레이션과 잘못된 행동을 야기할 수 있습니다. 200픽셀 정도로 된 물체에 대해 Box2D 에서는 45층짜리 빌딩으로 칩니다.


	(주의)
	Box2D 는 MKS 유닛에 맡게 조정되어 있습니다. 
	움직이는 물체는 0.1 미터 에서 10미터 정도로 해주세요. 
	아마도 당신의 환경 및 배우에 대한 거리 환산 시스템이 필요할 것 입니다. 
	Box2D testbed 에서는 OpenGL viewport transform 을 통해 이 거리 환산을 하였습니다. 
	픽셀 단위를 사용하지 말아주세요. (OpenGL 부동소수점 쓰죠..)


Box2D 에서 어떤 물체가 움직인다는 것은 칠판에 그림을 올려놓고 장난치는 것으로 생각하면 편합니다. 미터법을 사용하는 칠판 위에서 움직이려면 미터법을 픽셀 좌표로 바꿀 환산법이 필요합니다. 이 환산법을 이용해 당신의 스프라이트 객체를 움직이거나 할 수 있는겁니다.
Box2D는 각도를 라디안으로 사용합니다. 물체에 해당 회전값이 저장되나 그 값이 한없이 증가할 수 있으므로 정규화를 통해 너무 커지지 않도록 합니다. (b2Body::SetAngle를 사용)

# 1.8 Factories and Definitions

Box2D API 가 가장 중점적으로 생각한 것은 빠른 메모리 관리입니다. b2Body 나 b2Joint 를 만들면, b2World 에 있는 factory 함수를 부를 필요가 있습니다. 다른 방식으로 이 타입을 선언하려고 해서는 안됩니다.

다음은 객체 생성 함수입니다.

	b2Body* b2World::CreateBody(const b2BodyDef* def)
	b2Joint* b2World::CreateJoint(const b2JointDef* def)


그리고 객체 제거 함수입니다.

	void b2World::DestroyBody(b2Body* body)
	void b2World::DestroyJoint(b2Joint* joint)


물체(body) 나 관절(joint) 을 만들때는 이를 위한 모든 정보를 가진 definition을 만들어야 합니다. 이러한 접근 방식을 통해 생성시의 에러를 막을 수 있고, 함수의 파라미터를 줄일 수 있으며, 기본값을 세세하게 제공할 수 있고, 접근자의 수를 줄일 수 있습니다.
body(b2Body)가 부모가 되어 자식으로 fixture를 생성하고 제거 할 수 있습니다. 

	b2Fixture* b2Body::CreateFixture(const b2FixtureDef* def)
	void b2Body::DestroyFixture(b2Fixture* fixture)


형태와 밀도를 한번에 주어 쉽게 생성할 수 있는 방법도 제공합니다.

	b2Fixture* b2Body::CreateFixture(const b2Shape* shape, float32 density)


factory 는 definition 의 참조값을 1 증가(retain reference) 시키지 않습니다. 그러므로 생성한 definition 은 임시 리소스로 놔두면 됩니다. (definition 객체를 참조한다는게 아니라 객체의 정보를 body 나 joint 로 직접 넣으니 해당 definition의 값을 바꿔야 body 나 joint 에 적용이 된다던가 하는 구조가 아니라는 거 겠지요.)

# 1.9 User Data

b2Fixture, b2Body, b2Joint 클래스는 유저 데이터를 보이드 포인터로 해서 붙이는 것이 가능하다. Box2D의 자료구조를 실험하거나 게임엔진 안에 있는 요소들과 어떻게 결합하는지 알아볼 때 매우 유용하다.
예를 들어, actor 라는 강체에 actor 포인트를 붙인다면, 선형으로 참조를 하게 됩니다. actor 를 통해 body 를 구하고, body를 통해 actor 를 구할 수 있습니다.

	GameActor* actor = GameCreateActor(); 
	b2BodyDef bodyDef;
	bodyDef.userData = actor;
	actor->body = box2Dworld->CreateBody(&bodyDef);

user data 는 다음의 경우에 사용하십시요.

* 충돌 결과로 actor 가 데미지를 입을때
* 스크립트로 된 이벤트를 차원축에 따라 움직이는 공간 안에서 진행할때
* joint 가 제거될때 Box2D가 게임 내 자료에 접근하라고 알려야 할 경우 

user data 는 어디까지나 부가적인 기능이며, 여기에는 어떤 것이든지 집어넣을 수 있습니다. 그러나, 일관성이 유지되어야 합니다. 일례로, 하나의 body 에 actor 포인터를 저장한다면 모든 body 가 저장을 해야 합니다. 특정 body 에는 다른 actor 포인터를 저장하거나 하는 일을 하면 안됩니다. 캐스팅을 하더라도 크래쉬가 발생할 것 입니다. 
user data 포인터 의 디폴트 값은 NULL 입니다.